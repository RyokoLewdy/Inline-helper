<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hatsune Miku Profile Design - Image Upload</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 209, 214, 0.3);
        }
        
        #canvas {
            border: 2px solid #39C5BB;
            border-radius: 20px;
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,.03) 10px, rgba(255,255,255,.03) 20px),
                repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(0,0,0,.03) 10px, rgba(0,0,0,.03) 20px);
            cursor: crosshair;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(135deg, #39C5BB, #00D1D6);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(57, 197, 187, 0.5);
        }
        
        .color-input {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(57, 197, 187, 0.1);
            padding: 8px 15px;
            border-radius: 25px;
        }
        
        input[type="color"] {
            width: 40px;
            height: 40px;
            border: 2px solid #39C5BB;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="file"] {
            display: none;
        }
        
        input[type="range"] {
            width: 120px;
            cursor: pointer;
            accent-color: #39C5BB;
        }
        
        .upload-section {
            background: rgba(57, 197, 187, 0.05);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid #39C5BB;
            width: 100%;
            max-width: 900px;
        }
        
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .upload-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #FF6B9D, #FF8DB3);
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 20px;
        }
        
        .preview-box {
            width: 80px;
            height: 80px;
            border: 2px dashed #39C5BB;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: rgba(0,0,0,0.3);
        }
        
        .preview-box img {
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
        }
        
        .section-title {
            color: #00D1D6;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .miku-cutout-section {
            background: rgba(255, 107, 157, 0.05);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid #FF6B9D;
            width: 100%;
            max-width: 900px;
        }
        
        .miku-preview {
            width: 200px;
            height: 300px;
            border: 2px dashed #FF6B9D;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: rgba(0,0,0,0.3);
            margin: 0 auto;
        }
        
        .miku-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .opacity-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
        }
        
        .opacity-label {
            color: #39C5BB;
            font-size: 11px;
            min-width: 60px;
        }
        
        .opacity-value {
            color: #FF6B9D;
            font-size: 11px;
            font-weight: bold;
            min-width: 35px;
        }
        
        label {
            color: #39C5BB;
            font-weight: bold;
        }
        
        h1 {
            color: #00D1D6;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 209, 214, 0.5);
            margin: 0;
        }
        
        .info {
            color: #FF6B9D;
            text-align: center;
            font-size: 14px;
        }
        
        .image-label {
            color: #FF6B9D;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¤ Hatsune Miku Profile Design ðŸŽ¤</h1>
    <p class="info">1920x1080 | Transparent Background | Upload Your Images!</p>
    
    <!-- Upload Section for Main Miku Cutout -->
    <div class="miku-cutout-section">
        <div class="section-title">ðŸŽµ Main Miku Full Body Cutout (Left Side)</div>
        <div class="upload-item">
            <div class="miku-preview" id="preview-miku-cutout"></div>
            <button class="upload-btn" onclick="document.getElementById('miku-cutout').click()">Upload Miku</button>
            <input type="file" id="miku-cutout" accept="image/*" onchange="handleImageUpload(event, 'cutout', 0)">
            <div class="image-label">Full body PNG recommended</div>
            <div class="opacity-control">
                <span class="opacity-label">Opacity:</span>
                <input type="range" id="opacity-cutout" min="0" max="100" value="100" oninput="updateOpacity('cutout', 0, this.value)">
                <span class="opacity-value" id="value-cutout">100%</span>
            </div>
        </div>
    </div>
    
    <!-- Upload Section for Large Diamonds -->
    <div class="upload-section">
        <div class="section-title">ðŸ“¸ Large Diamond Images (Main)</div>
        <div class="upload-grid">
            <div class="upload-item">
                <div class="image-label">Large Diamond 1</div>
                <div class="preview-box" id="preview-large-1"></div>
                <button class="upload-btn" onclick="document.getElementById('large-1').click()">Upload</button>
                <input type="file" id="large-1" accept="image/*" onchange="handleImageUpload(event, 'large', 0)">
                <div class="opacity-control">
                    <span class="opacity-label">Opacity:</span>
                    <input type="range" id="opacity-large-1" min="0" max="100" value="100" oninput="updateOpacity('large', 0, this.value)">
                    <span class="opacity-value" id="value-large-1">100%</span>
                </div>
            </div>
            <div class="upload-item">
                <div class="image-label">Large Diamond 2</div>
                <div class="preview-box" id="preview-large-2"></div>
                <button class="upload-btn" onclick="document.getElementById('large-2').click()">Upload</button>
                <input type="file" id="large-2" accept="image/*" onchange="handleImageUpload(event, 'large', 1)">
                <div class="opacity-control">
                    <span class="opacity-label">Opacity:</span>
                    <input type="range" id="opacity-large-2" min="0" max="100" value="100" oninput="updateOpacity('large', 1, this.value)">
                    <span class="opacity-value" id="value-large-2">100%</span>
                </div>
            </div>
            <div class="upload-item">
                <div class="image-label">Large Diamond 3</div>
                <div class="preview-box" id="preview-large-3"></div>
                <button class="upload-btn" onclick="document.getElementById('large-3').click()">Upload</button>
                <input type="file" id="large-3" accept="image/*" onchange="handleImageUpload(event, 'large', 2)">
                <div class="opacity-control">
                    <span class="opacity-label">Opacity:</span>
                    <input type="range" id="opacity-large-3" min="0" max="100" value="100" oninput="updateOpacity('large', 2, this.value)">
                    <span class="opacity-value" id="value-large-3">100%</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Upload Section for Small Diamonds -->
    <div class="upload-section">
        <div class="section-title">ðŸ“¸ Small Portrait Diamonds (Right Side)</div>
        <div class="upload-grid">
            <div class="upload-item">
                <div class="image-label">Small Diamond 1</div>
                <div class="preview-box" id="preview-small-1"></div>
                <button class="upload-btn" onclick="document.getElementById('small-1').click()">Upload</button>
                <input type="file" id="small-1" accept="image/*" onchange="handleImageUpload(event, 'small', 0)">
                <div class="opacity-control">
                    <span class="opacity-label">Opacity:</span>
                    <input type="range" id="opacity-small-1" min="0" max="100" value="100" oninput="updateOpacity('small', 0, this.value)">
                    <span class="opacity-value" id="value-small-1">100%</span>
                </div>
            </div>
            <div class="upload-item">
                <div class="image-label">Small Diamond 2</div>
                <div class="preview-box" id="preview-small-2"></div>
                <button class="upload-btn" onclick="document.getElementById('small-2').click()">Upload</button>
                <input type="file" id="small-2" accept="image/*" onchange="handleImageUpload(event, 'small', 1)">
                <div class="opacity-control">
                    <span class="opacity-label">Opacity:</span>
                    <input type="range" id="opacity-small-2" min="0" max="100" value="100" oninput="updateOpacity('small', 1, this.value)">
                    <span class="opacity-value" id="value-small-2">100%</span>
                </div>
            </div>
            <div class="upload-item">
                <div class="image-label">Small Diamond 3</div>
                <div class="preview-box" id="preview-small-3"></div>
                <button class="upload-btn" onclick="document.getElementById('small-3').click()">Upload</button>
                <input type="file" id="small-3" accept="image/*" onchange="handleImageUpload(event, 'small', 2)">
                <div class="opacity-control">
                    <span class="opacity-label">Opacity:</span>
                    <input type="range" id="opacity-small-3" min="0" max="100" value="100" oninput="updateOpacity('small', 2, this.value)">
                    <span class="opacity-value" id="value-small-3">100%</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <canvas id="canvas" width="2100" height="1200"></canvas>
    </div>
    
    <div class="controls">
        <div class="color-input">
            <label>Primary Color:</label>
            <input type="color" id="primaryColor" value="#39C5BB">
        </div>
        <div class="color-input">
            <label>Accent Color:</label>
            <input type="color" id="accentColor" value="#FF6B9D">
        </div>
        <button onclick="redraw()">ðŸŽ¨ Redraw</button>
        <button onclick="downloadImage()">ðŸ’¾ Download PNG</button>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Define safe zone boundaries for 1920x1080 export
        const SAFE_ZONE = {
            x: 90,
            y: 60,
            width: 1920,
            height: 1080
        };
        
        let primaryColor = '#39C5BB';
        let accentColor = '#FF6B9D';
        
        // Store uploaded images
        let largeImages = [null, null, null];
        let smallImages = [null, null, null];
        let mikuCutout = null;
        
        // Store opacity values (0-100)
        let largeOpacity = [100, 100, 100];
        let smallOpacity = [100, 100, 100];
        let cutoutOpacity = 100;
        
        document.getElementById('primaryColor').addEventListener('change', (e) => {
            primaryColor = e.target.value;
            redraw();
        });
        
        document.getElementById('accentColor').addEventListener('change', (e) => {
            accentColor = e.target.value;
            redraw();
        });
        
        function updateOpacity(type, index, value) {
            if (type === 'large') {
                largeOpacity[index] = parseInt(value);
                document.getElementById(`value-large-${index + 1}`).textContent = value + '%';
            } else if (type === 'small') {
                smallOpacity[index] = parseInt(value);
                document.getElementById(`value-small-${index + 1}`).textContent = value + '%';
            } else if (type === 'cutout') {
                cutoutOpacity = parseInt(value);
                document.getElementById('value-cutout').textContent = value + '%';
            }
            redraw();
        }
        
        function handleImageUpload(event, type, index) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    if (type === 'large') {
                        largeImages[index] = img;
                        document.getElementById(`preview-large-${index + 1}`).innerHTML = `<img src="${e.target.result}">`;
                    } else if (type === 'small') {
                        smallImages[index] = img;
                        document.getElementById(`preview-small-${index + 1}`).innerHTML = `<img src="${e.target.result}">`;
                    } else if (type === 'cutout') {
                        mikuCutout = img;
                        document.getElementById('preview-miku-cutout').innerHTML = `<img src="${e.target.result}">`;
                    }
                    redraw();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function drawGradientSplash(x, y, radius, color, opacity = 0.6) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, color + Math.floor(opacity * 255).toString(16).padStart(2, '0'));
            gradient.addColorStop(0.5, color + '44');
            gradient.addColorStop(1, color + '00');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawImageInDiamond(img, x, y, size, rotation, opacity = 1.0) {
            if (!img) return;
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            // Create diamond clipping path
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size, 0);
            ctx.closePath();
            ctx.clip();
            
            // Calculate scaling to cover the diamond
            const scale = Math.max(size * 2 / img.width, size * 2 / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Draw image centered
            ctx.drawImage(img, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
            
            ctx.restore();
            
            // Draw diamond border on top
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size, 0);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }
        
        function drawImageInSmallDiamond(img, x, y, size, opacity = 1.0) {
            if (!img) {
                // Draw placeholder if no image
                drawSmallDiamond(x, y, size);
                ctx.fillStyle = 'rgba(57, 197, 187, 0.3)';
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(45 * Math.PI / 180);
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.restore();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('M', x, y);
                return;
            }
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.translate(x, y);
            ctx.rotate(45 * Math.PI / 180);
            
            // Create square clipping path
            ctx.beginPath();
            ctx.rect(-size/2, -size/2, size, size);
            ctx.clip();
            
            // Calculate scaling
            const scale = Math.max(size / img.width, size / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Draw image centered
            ctx.drawImage(img, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
            
            ctx.restore();
            
            // Draw border
            drawSmallDiamond(x, y, size);
        }
        
        function drawDiamond(x, y, size, rotation, strokeWidth = 4) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size, 0);
            ctx.closePath();
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = strokeWidth;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawSmallDiamond(x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(45 * Math.PI / 180);
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.strokeRect(-size/2, -size/2, size, size);
            
            ctx.restore();
        }
        
        function drawMikuCutout(img, x, y, maxHeight, opacity = 1.0) {
            if (!img) return;
            
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Calculate scaling to fit maxHeight while maintaining aspect ratio
            const scale = maxHeight / img.height;
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Add glow effect around Miku
            ctx.shadowColor = primaryColor;
            ctx.shadowBlur = 30;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw image
            ctx.drawImage(img, x - scaledWidth / 2, y - scaledHeight / 2, scaledWidth, scaledHeight);
            
            ctx.restore();
        }
        
        function drawMikuBanner(x, y, width, height, rotation, text, subtext) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            // Create gradient background (teal to cyan)
            const gradient = ctx.createLinearGradient(-width/2, 0, width/2, 0);
            gradient.addColorStop(0, primaryColor);
            gradient.addColorStop(0.5, '#00D1D6');
            gradient.addColorStop(1, primaryColor);
            
            // Main banner shape - smooth rounded corners
            const radius = 20;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(-width/2 + radius + 20, -height/2);
            ctx.lineTo(width/2 - radius, -height/2);
            ctx.arcTo(width/2, -height/2, width/2, -height/2 + radius, radius);
            ctx.lineTo(width/2 - 20, height/2 - radius);
            ctx.arcTo(width/2 - 20, height/2, width/2 - 20 - radius, height/2, radius);
            ctx.lineTo(-width/2 + radius, height/2);
            ctx.arcTo(-width/2, height/2, -width/2, height/2 - radius, radius);
            ctx.lineTo(-width/2 + 20, -height/2 + radius);
            ctx.arcTo(-width/2 + 20, -height/2, -width/2 + 20 + radius, -height/2, radius);
            ctx.closePath();
            ctx.fill();
            
            // Add subtle inner glow
            ctx.shadowColor = primaryColor;
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // White outline
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Add pink accent border on inside
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            
            // Advanced text styling
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            
            // Main text - "MIKU" with idol-style font
            ctx.font = 'bold 85px "Comic Sans MS", "Marker Felt", "Brush Script MT", cursive, Impact';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add italic slant for dynamic look
            ctx.save();
            ctx.transform(1, 0, -0.15, 1, 0, 0);
            
            // Triple outline effect for depth
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 12;
            ctx.strokeText(text, 0, -15);
            
            ctx.strokeStyle = primaryColor;
            ctx.lineWidth = 7;
            ctx.strokeText(text, 0, -15);
            
            ctx.strokeStyle = '#003333';
            ctx.lineWidth = 3;
            ctx.strokeText(text, 0, -15);
            
            ctx.fillStyle = 'white';
            ctx.fillText(text, 0, -15);
            
            // Add highlight/shine effect
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.5;
            const highlightGradient = ctx.createLinearGradient(0, -60, 0, -5);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = highlightGradient;
            ctx.fillText(text, 0, -15);
            ctx.globalAlpha = 1.0;
            
            ctx.restore();
            
            // Subtext
            ctx.shadowBlur = 10;
            ctx.font = 'bold 38px "Trebuchet MS", "Lucida Sans", sans-serif';
            ctx.letterSpacing = '3px';
            
            ctx.strokeStyle = primaryColor;
            ctx.lineWidth = 6;
            ctx.strokeText(subtext, 0, 40);
            
            ctx.strokeStyle = '#003333';
            ctx.lineWidth = 2;
            ctx.strokeText(subtext, 0, 40);
            
            ctx.fillStyle = 'white';
            ctx.fillText(subtext, 0, 40);
            
            // Add sparkles
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            
            const sparkles = [
                {x: -width/2 + 80, y: -25},
                {x: width/2 - 80, y: -25},
                {x: -width/3, y: 55},
                {x: width/3, y: 55}
            ];
            
            sparkles.forEach(sparkle => {
                drawSparkle(sparkle.x, sparkle.y, 6);
            });
            
            ctx.restore();
        }
        
        function drawSparkle(x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            
            for (let i = 0; i < 4; i++) {
                const angle = (Math.PI / 2) * i;
                const x1 = Math.cos(angle) * size;
                const y1 = Math.sin(angle) * size;
                const x2 = Math.cos(angle + Math.PI / 4) * (size * 0.3);
                const y2 = Math.sin(angle + Math.PI / 4) * (size * 0.3);
                
                if (i === 0) {
                    ctx.moveTo(x1, y1);
                } else {
                    const prevAngle = (Math.PI / 2) * (i - 1) + Math.PI / 4;
                    const prevX = Math.cos(prevAngle) * (size * 0.3);
                    const prevY = Math.sin(prevAngle) * (size * 0.3);
                    ctx.lineTo(prevX, prevY);
                    ctx.lineTo(x1, y1);
                }
            }
            
            ctx.closePath();
            ctx.fill();
            
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 8;
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawMusicalNote(x, y, size, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â™ª', 0, 0);
            
            ctx.restore();
        }
        
        function drawDigitalCode(x, y, opacity = 0.2) {
            ctx.save();
            ctx.fillStyle = `rgba(57, 197, 187, ${opacity})`;
            ctx.font = 'bold 200px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('01', x, y);
            ctx.restore();
        }
        
        function drawGlowingLine(x1, y1, x2, y2, color, width = 3) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.shadowColor = color;
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawParticles() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3 + 1;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function redraw() {
            // Clear canvas with transparency
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Color splashes
            drawGradientSplash(600, 500, 450, primaryColor, 0.5);
            drawGradientSplash(1000, 650, 400, '#00D1D6', 0.4);
            drawGradientSplash(1400, 400, 350, accentColor, 0.3);
            drawGradientSplash(800, 850, 380, primaryColor, 0.35);
            
            // Digital code background
            drawDigitalCode(500, 400, 0.15);
            drawDigitalCode(1600, 850, 0.15);
            
            // Particles
            drawParticles();
            
            // Glowing lines
            drawGlowingLine(400, 300, 1700, 400, primaryColor, 2);
            drawGlowingLine(450, 950, 1600, 850, '#FF6B9D', 2);
            drawGlowingLine(300, 600, 550, 400, '#00D1D6', 2);
            
            // Draw Main Miku Cutout with opacity
            if (mikuCutout) {
                drawMikuCutout(mikuCutout, 380, 600, 900, cutoutOpacity / 100);
            }
            
            // Draw large diamonds with images and opacity
            const largeDiamonds = [
                { x: 920, y: 450, size: 330, rotation: 45 },
                { x: 1250, y: 600, size: 300, rotation: 15 },
                { x: 1530, y: 400, size: 280, rotation: -20 }
            ];
            
            largeDiamonds.forEach((diamond, index) => {
                if (largeImages[index]) {
                    drawImageInDiamond(largeImages[index], diamond.x, diamond.y, diamond.size, diamond.rotation, largeOpacity[index] / 100);
                } else {
                    drawDiamond(diamond.x, diamond.y, diamond.size, diamond.rotation, 4);
                }
            });
            
            // Draw small portrait diamonds with images and opacity
            const portraitX = 1830;
            const portraitYStart = 700;
            for (let i = 0; i < 3; i++) {
                const y = portraitYStart + (i * 130);
                drawImageInSmallDiamond(smallImages[i], portraitX, y, 80, smallOpacity[i] / 100);
            }
            
            // Musical notes scattered
            drawMusicalNote(620, 320, 48, 15);
            drawMusicalNote(1420, 280, 56, -20);
            drawMusicalNote(1650, 520, 40, 10);
            drawMusicalNote(850, 920, 44, -15);
            drawMusicalNote(1230, 970, 52, 25);
            drawMusicalNote(400, 720, 36, 0);
            
            // Miku-styled banner
            drawMikuBanner(1050, 800, 780, 140, -3, 'Miku', 'Hatsune');
            
            // Additional accent lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
                const x1 = SAFE_ZONE.x + 100 + Math.random() * (SAFE_ZONE.width - 200);
                const y1 = SAFE_ZONE.y + 100 + Math.random() * (SAFE_ZONE.height - 200);
                const length = Math.random() * 100 + 50;
                const angle = Math.random() * 360;
                const x2 = x1 + Math.cos(angle * Math.PI / 180) * length;
                const y2 = y1 + Math.sin(angle * Math.PI / 180) * length;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        function downloadImage() {
            // Create a temporary canvas for final export at 1920x1080
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = 1920;
            exportCanvas.height = 1080;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Draw the safe zone area
            exportCtx.drawImage(
                canvas, 
                SAFE_ZONE.x, SAFE_ZONE.y, SAFE_ZONE.width, SAFE_ZONE.height,
                0, 0, 1920, 1080
            );
            
            // Download the cropped image
            const link = document.createElement('a');
            link.download = 'hatsune-miku-profile-1920x1080.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }
        
        // Initial draw
        redraw();
    </script>
</body>
</html>